{"version":3,"sources":["../src/index.ts","../src/ListenerCleaner.ts","../src/Id.ts","../src/PromiseQueue.ts","../src/MultiQueue.ts"],"sourcesContent":["export * from \"./ListenerCleaner\";\r\nexport * from \"./PromiseQueue\";\r\nexport * from \"./MultiQueue\";\r\nexport * from \"./Id\";\r\nexport * from \"./Lazy\";\r\n","export class ListenerCleaner {\r\n    cleaners: (() => void)[] = [];\r\n\r\n    add(cleanerCallback: () => void) {\r\n        this.cleaners.push(cleanerCallback);\r\n    }\r\n\r\n    cleaner(): () => void {\r\n        return () => {\r\n            this.cleanUp();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call all the cleaner callbacks and reset this cleaner to be reused.\r\n     */\r\n    cleanUp() {\r\n        for (const cleaner of this.cleaners) {\r\n            cleaner();\r\n        }\r\n        this.cleaners = [];\r\n    }\r\n}\r\n","export function makeid(length) {\r\n    let result           = '';\r\n    let characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    let charactersLength = characters.length;\r\n    for ( let i = 0; i < length; i++ ) {\r\n        result += characters.charAt(Math.floor(Math.random() *\r\n            charactersLength));\r\n    }\r\n    return result;\r\n}","import {makeid} from \"./Id\";\r\n\r\nexport class PromiseQueue<T> {\r\n    private nextPromise: Promise<T> = Promise.resolve(null);\r\n    private canceled = {};\r\n    private queueSize = 0;\r\n    private queueID = 0;\r\n\r\n    /**\r\n     *\r\n     * @param onlyLast if true all task are cancel and only the last one is keep alive (a task started still finishes)\r\n     */\r\n    constructor(\r\n        private onlyLast: boolean = false\r\n    ) {\r\n        this.cancelAll();\r\n    }\r\n\r\n    getQueueSize(): number {\r\n        return this.queueSize;\r\n    }\r\n\r\n    async awaitQueueEmpty(){\r\n        await this.nextPromise;//await the current promise\r\n        while (this.queueSize!=0){//await all the fowllofing promise\r\n            await this.nextPromise;\r\n        }\r\n    }\r\n\r\n    add(task: () => Promise<T>, id: string = null): { id: string, promise: Promise<T> } {\r\n        if (!id) {\r\n            id = \"promise-\" + makeid(8);\r\n        }\r\n        let lastPromise = this.nextPromise;\r\n        this.queueSize++;\r\n        let currentID = this.queueID;\r\n        let currentPromise=null;\r\n        currentPromise = (async () => {\r\n            this.queueSize--;\r\n            try {\r\n                await lastPromise;\r\n            }catch (e) {\r\n                /* ignore error of previous promise*/\r\n            }\r\n            if(currentID!==this.queueID){\r\n                throw new Error(\"canceled caused by new queue\");\r\n            }\r\n            if (this.canceled[id]) {\r\n                delete this.canceled[id];\r\n                throw new Error(\"canceled by user\");\r\n            }\r\n            if(this.onlyLast && currentPromise!=this.nextPromise){\r\n                throw new Error(\"canceled caused by not last\");\r\n            }\r\n            //execute task and return result\r\n            return task();\r\n        })();\r\n        currentPromise.catch(e=>{\r\n            /* we catch the exception this way to avoid an uncaught exception in the console*/\r\n        });\r\n        this.nextPromise = currentPromise\r\n        return {id, promise: this.nextPromise};\r\n    }\r\n\r\n    cancel(id: string) {\r\n        this.canceled[id] = true;\r\n    }\r\n\r\n    /**\r\n     * The last task in progress is not canceled\r\n     */\r\n    async cancelAll(){\r\n        this.queueID++;//create a new queue will cancel all previous task except the one in progress\r\n        await this.awaitQueueEmpty();\r\n        this.nextPromise = Promise.resolve(null);\r\n        this.canceled = {};\r\n        this.queueSize = 0;\r\n    }\r\n\r\n}\r\n","import {PromiseQueue} from \"./PromiseQueue\";\r\n\r\nexport class MultiQueue<T> {\r\n    private readonly queues:PromiseQueue<T>[];\r\n\r\n    /**\r\n     *\r\n     * @param concurrentTask\r\n     */\r\n    constructor(\r\n        concurrentTask:number=1,\r\n    ) {\r\n        if (concurrentTask<1){\r\n            throw new Error(\"concurrentTask must be >=1\");\r\n        }\r\n        this.queues = [];\r\n        for(let i=0;i<concurrentTask;i++){\r\n            this.queues.push(new PromiseQueue<T>());\r\n        }\r\n    }\r\n\r\n    public getQueueSize(): number {\r\n        let ret = 0;\r\n        for(let queue of this.queues){\r\n            ret+=queue.getQueueSize();\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public async awaitQueueEmpty(){\r\n        for(let queue of this.queues){\r\n            await queue.awaitQueueEmpty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a task to the queue. The queue with the smallest task size is used\r\n     * @param task\r\n     * @param id\r\n     **/\r\n    public add(task: () => Promise<T>, id: string = null): { id: string, promise: Promise<T> } {\r\n        let queue = this.queues[0];\r\n        for(let i=1;i<this.queues.length;i++){\r\n            if(this.queues[i].getQueueSize()<queue.getQueueSize()){\r\n                queue = this.queues[i];\r\n            }\r\n        }\r\n        return queue.add(task,id);\r\n    }\r\n\r\n    public cancel(id: string) {\r\n        for(let queue of this.queues){\r\n            queue.cancel(id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The last task in progress is not canceled\r\n     */\r\n    public async cancelAll(){\r\n        for(let queue of this.queues){\r\n            await queue.cancelAll();\r\n        }\r\n    }\r\n\r\n}\r\n"],"mappings":"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","names":["src_exports","__export","ListenerCleaner","MultiQueue","PromiseQueue","makeid","__toCommonJS","ListenerCleaner","cleanerCallback","cleaner","makeid","length","result","characters","charactersLength","i","PromiseQueue","onlyLast","task","id","makeid","lastPromise","currentID","currentPromise","e","MultiQueue","concurrentTask","i","PromiseQueue","ret","queue","task","id"]}